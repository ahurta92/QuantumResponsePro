from quantumresponsepro import DaltonRunner
from pathlib import Path
import glob
import json
#from mergedeep import merge, Strategy


class GenerateDatabasePaths:
    """
    Class to generate paths for database.
    The class defines the file structure of the database
    """

    def __init__(self, database_path: Path):
        self.dalton_path = database_path.joinpath("dalton")
        self.molecule_path = database_path.joinpath("molecules")
        self.json_path = database_path.joinpath("json_data")
        self.dalton_excited = self.json_path.joinpath('dalton-excited.json')
        self.dalton_dipole = self.json_path.joinpath('dalton-dipole.json')
        self.dalton_quad_response = self.json_path.joinpath('quad-dipole.json')
        self.frequency_json = self.json_path.joinpath('frequency.json')
        self.excited_keys = self.json_path.joinpath(
            'molecule_excited_state_keys.json')


class DatabaseGenerator:
    """
    Class to generate data for database.
    """

    def __load_and_merge_json(self, path: Path, new_json: dict):
        """
        :param path: Path to json file
        :param new_json: New json data to merge with old json data
        Will load a json file and merge it with a new json file.
        If does not exist, will save new json file into location.
        """
        if path.exists():
            with open(path, 'r') as f:
                old_json = json.load(f)
                old_json = merge(old_json, new_json, strategy=Strategy.ADDITIVE)
            with open(path, 'w') as f:
                json.dump(old_json, f, indent=4)
        else:
            with open(path, 'w') as f:
                json.dump(new_json, f, indent=4)

    def get_molecule_list(self):

        mol_p = glob.glob('*mol', root_dir=self.molecule_path)
        molecule_list = [mol.split('.')[0] for mol in mol_p]

        return molecule_list

    def __init__(self, database_path: Path):
        self.database_path = database_path
        self.paths = GenerateDatabasePaths(database_path)
        self.dalton_path = self.paths.dalton_path
        self.molecule_path = self.paths.molecule_path
        self.json_path = self.paths.json_path

    def __generate_molecule_excited_state_keys(self, num_states,
                                               overwrite: bool = False):
        """
        Generate excited state keys for a given molecule, xc functional
        and basis set. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """

        if self.paths.excited_keys.exists():
            with open(self.paths.excited_keys, 'r') as f:
                mol_excited_dict = json.load(f)
            if overwrite:
                mol_list = self.get_molecule_list()
                print(mol_list)
                mol_excited_dict = {mol: num_states for mol in mol_list}
                with open(self.paths.excited_keys, 'w') as f:
                    f.write(json.dumps(mol_excited_dict, indent=4))
            return mol_excited_dict
        else:
            mol_list = self.get_molecule_list()
            mol_excited_dict = {mol: num_states for mol in mol_list}
            if overwrite:
                with open(self.paths.excited_keys, 'w') as f:
                    f.write(json.dumps(mol_excited_dict, indent=4))
            return mol_excited_dict

    def __generate_dalton_excited_state_json(self, xc, basis_list,
                                             run: bool = False):
        """
        Generate excited state json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """
        molecule_list = self.get_molecule_list()
        print('database path', self.database_path)
        print('molecule path', self.molecule_path)

        dal_runner = DaltonRunner(self.database_path, run)

        if self.paths.excited_keys.exists():
            with open(self.paths.excited_keys, 'r') as f:
                excited_json_keys = json.load(f)
        else:
            excited_json_keys = self.__generate_molecule_excited_state_keys(4,
                                                                            True)
        print(molecule_list)

        data_dict = {xc: {}}
        for molecule in molecule_list:
            data_dict[xc][molecule] = {}
            for basis in basis_list:
                try:
                    data_dict[xc][molecule][basis] = \
                        dal_runner.get_excited_json(molecule, xc, basis,
                                                    excited_json_keys[molecule])[basis]
                except TypeError:
                    data_dict[xc][molecule][basis] = {}

        return data_dict

    def get_dalton_excited_json(self, xc, basis_list, run):
        """
        :param xc: xc functional
        :param basis_list: list of basis sets
        :param run: run dalton if data is not found
        Get excited state json files for a given xc functional and basis set.
        If data is not found can be generated by running dalton with run = True.
        First checks if excited state json file exists in json_data directory.
        If it does not exist it will generate the json file.
        If it does exist it will merge the new data with the old data.
        """

        if not self.json_path.exists():
            self.json_path.mkdir()
        excited_json = self.__generate_dalton_excited_state_json(xc, basis_list, run)
        self.__load_and_merge_json(self.paths.dalton_excited, excited_json)
        return excited_json

    def __generate_dalton_frequency_json(self, xc, op, basis_list,
                                         run: bool = False):
        """
        Generate frequency state json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """
        molecule_list = self.get_molecule_list()
        print('database path', self.database_path)
        print('molecule path', self.molecule_path)

        dal_runner = DaltonRunner(self.database_path, run)

        data_dict = {}
        for molecule in molecule_list:

            data_dict[molecule] = {xc: {op: {}}}
            for basis in basis_list:
                try:
                    data_dict[molecule][xc][op][basis] = \
                        dal_runner.get_polar_json(molecule, xc, op, basis)[basis]
                except TypeError as t:
                    data_dict[molecule][xc][op][basis] = {}

            print(data_dict)

        return data_dict

    def __generate_dalton_quad_json(self, xc, op, basis_list,
                                    run: bool = False):
        """
        Generate frequency state json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """
        molecule_list = self.get_molecule_list()
        print('database path', self.database_path)
        print('molecule path', self.molecule_path)

        dal_runner = DaltonRunner(self.database_path, run)

        data_dict = {}
        for molecule in molecule_list:

            data_dict[molecule] = {xc: {op: {}}}
            for basis in basis_list:
                try:
                    data_dict[molecule][xc][op][basis] = \
                        dal_runner.get_quad_json(molecule, xc, op, basis)[basis]
                except TypeError as t:
                    data_dict[molecule][xc][op][basis] = {}
                except ValueError as v:
                    "No data found for molecule, xc, op, basis"
                    data_dict[molecule][xc][op][basis] = {}

            print(data_dict)

        return data_dict

    def get_dalton_frequency_json(self, xc, op, basis_list, run):
        """
        :param xc: xc functional
        :param basis_list: list of basis sets
        :param run: run dalton if data is not found
        Get excited state json files for a given xc functional and basis set.
        If data is not found can be generated by running dalton with run = True.
        First checks if excited state json file exists in json_data directory.
        If it does not exist it will generate the json file.
        If it does exist it will merge the new data with the old data.
        """

        dalton_frequency_json = self.__generate_dalton_frequency_json(xc, op, basis_list, run)
        self.__load_and_merge_json(self.paths.dalton_dipole, dalton_frequency_json)

        return dalton_frequency_json

    def get_dalton_quad_json(self, xc, op, basis_list, run):
        """
        :param xc: xc functional
        :param basis_list: list of basis sets
        :param run: run dalton if data is not found
        Get excited state json files for a given xc functional and basis set.
        If data is not found can be generated by running dalton with run = True.
        First checks if excited state json file exists in json_data directory.
        If it does not exist it will generate the json file.
        If it does exist it will merge the new data with the old data.
        """

        dalton_quad_json = self.__generate_dalton_quad_json(xc, op, basis_list, run)
        self.__load_and_merge_json(self.paths.dalton_quad_response, dalton_quad_json)

        return dalton_quad_json

    def get_frequency_json(self, num_steps_to_max: int, xc: str, op: str,
                           basis: str, frac_max=.5):
        """
        :param num_steps_to_max: number of steps to maximum frequency
        :param xc: xc functional
        :param op: operator
        :param basis: basis set
        :param frac_max: fraction of maximum frequency to use
        Generate frequency json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """
        try:
            with open(self.paths.dalton_excited, 'r') as f:
                print(self.paths.dalton_excited)
                excited_json = json.load(f)
                freq_j = {}
                for molecule in self.get_molecule_list():
                    print(basis)
                    print("molexcited data", molecule, excited_json[xc][molecule][basis])
                    omega_max = \
                        excited_json[xc][molecule][basis]['response']['freq'][0]
                    omega_max = frac_max * omega_max
                    freqs = [float(i) * omega_max / num_steps_to_max for i in
                             range(num_steps_to_max + 1)]
                    freq_j[molecule] = {xc: {op: freqs}}

        except FileNotFoundError as f:
            print(f)
            print(self.paths.dalton_excited, ' not found')
            return None
        except TypeError as t:
            print(t)
            print('No excited states found')
            return None
        print("freq_j", freq_j)

        if self.paths.frequency_json.exists():
            old_frequency_json = json.load(open(self.paths.frequency_json, 'r'))
            old_frequency_json.update(freq_j)
            with open(self.paths.frequency_json, 'w') as f:
                f.write(json.dumps(old_frequency_json, indent=4))
        else:
            with open(self.paths.frequency_json, 'w') as f:
                f.write(json.dumps(freq_j, indent=4))

        return freq_j
