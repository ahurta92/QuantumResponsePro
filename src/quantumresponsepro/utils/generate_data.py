from quantumresponsepro import DaltonRunner
from quantumresponsepro import DaltonRunner
from pathlib import Path
import glob
import json
from mergedeep import merge


class GenerateDatabasePaths:
    """
    Class to generate paths for database.
    The class defines the file structure of the database
    """

    def __init__(self, database_path: Path):
        self.dalton_path = database_path.joinpath("dalton")
        self.molecule_path = database_path.joinpath("molecules")
        self.json_path = database_path.joinpath("json_data")
        self.dalton_excited = self.json_path.joinpath('dalton_excited.json')
        self.frequency_json = self.json_path.joinpath('frequency.json')
        self.excited_keys = self.json_path.joinpath('molecule_excited_state_keys.json')


class DatabaseGenerator:
    """
    Class to generate data for database.
    """

    def get_molecule_list(self):

        mol_p = glob.glob('*mol', root_dir=self.molecule_path)
        molecule_list = [mol.split('.')[0] for mol in mol_p]
        print(molecule_list)

        return molecule_list

    def __init__(self, database_path: Path):
        self.database_path = database_path
        self.paths = GenerateDatabasePaths(database_path)
        self.dalton_path = self.paths.dalton_path
        self.molecule_path = self.paths.molecule_path
        self.json_path = self.paths.json_path

    def __generate_molecule_excited_state_keys(self, num_states, overwrite: bool = False):
        """
        Generate excited state keys for a given molecule, xc functional
        and basis set. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """

        if self.paths.excited_keys.exists():
            with open(self.paths.excited_keys, 'r') as f:
                mol_excited_dict = json.load(f)
            if overwrite:
                mol_list = self.get_molecule_list()
                mol_excited_dict = {mol: num_states for mol in mol_list}
                with open(self.paths.excited_keys, 'w') as f:
                    f.write(json.dumps(mol_excited_dict, indent=4))
            return mol_excited_dict
        else:
            mol_list = self.get_molecule_list()
            mol_excited_dict = {mol: num_states for mol in mol_list}
            if overwrite:
                with open(self.paths.excited_keys, 'w') as f:
                    f.write(json.dumps(mol_excited_dict, indent=4))
            return mol_excited_dict

    def generate_dalton_excited_state_json(self, xc, basis_list, run: bool = False):
        """
        Generate excited state json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """
        molecule_list = self.get_molecule_list()
        print('database path', self.database_path)
        print('molecule path', self.molecule_path)

        dal_runner = DaltonRunner(self.database_path, run)

        if self.paths.excited_keys.exists():
            with open(self.paths.excited_keys, 'r') as f:
                excited_json_keys = json.load(f)
        else:
            excited_json_keys = self.__generate_molecule_excited_state_keys(4, True)

        data_dict = {xc: {}}
        for molecule in molecule_list:
            data_dict[xc][molecule] = {}
            for basis in basis_list:
                data_dict[xc][molecule] = dal_runner.get_excited_json(molecule, xc, basis, run,
                                                                      excited_json_keys[molecule])

        return data_dict

    def get_dalton_excited_json(self, xc, basis_list, run):

        if not self.json_path.exists():
            self.json_path.mkdir()
        excited_json = self.generate_dalton_excited_state_json(xc, basis_list, run)

        if self.paths.dalton_excited.exists():
            with open(self.paths.dalton_excited, 'r') as f:
                old_excited_state_json = json.load(f)
                excited_json = merge(old_excited_state_json, excited_json)
            with open(self.paths.dalton_excited, 'w') as f:
                json.dump(excited_json, f, indent=4)
        else:
            with open(self.paths.dalton_excited, 'w') as f:
                json.dump(excited_json, f, indent=4)
        return excited_json

    def get_frequency_json(self, num_steps_to_max: int, xc: str, op: str, basis: str):
        """
        Generate frequency json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """

        try:
            with open(self.paths.dalton_excited, 'r') as f:
                excited_json = json.load(f)
                freq_j = {}
                for molecule in self.get_molecule_list():
                    omega_max = excited_json[xc][molecule][basis]['response']['freq'][0]
                    omega_max = omega_max / 2.0
                    freqs = [float(i) * omega_max / num_steps_to_max for i in range(num_steps_to_max + 1)]
                    freq_j[molecule] = {xc: {op: freqs}}

        except FileNotFoundError as f:
            print(f)
            print(self.paths.dalton_excited, ' not found')
            return None
        except TypeError as t:
            print(t)
            print('No excited states found')
            return None

        if self.paths.frequency_json.exists():
            old_frequency_json = json.load(open(self.paths.frequency_json, 'r'))
            old_frequency_json.update(freq_j)
            with open(self.paths.frequency_json, 'w') as f:
                f.write(json.dumps(old_frequency_json, indent=4))
        else:
            with open(self.paths.frequency_json, 'w') as f:
                f.write(json.dumps(freq_j, indent=4))

        return freq_j
