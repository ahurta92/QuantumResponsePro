from quantumresponsepro import DaltonRunner
from quantumresponsepro import DaltonRunner
from pathlib import Path
import glob
import json


class GenerateDatabasePaths:
    """
    Class to generate paths for database.
    The class defines the file structure of the database
    """

    def __init__(self, database_path: Path):
        self.dalton_path = database_path.joinpath("dalton")
        self.molecule_path = database_path.joinpath("molecules")
        self.json_path = database_path.joinpath("json_data")
        self.dalton_excited = self.json_path.joinpath('dalton_excited.json')


class DatabaseGenerator:
    """
    Class to generate data for database.
    """

    def get_molecule_list(self):

        mol_p = glob.glob('*mol', root_dir=self.molecule_path)
        molecule_list = [mol.split('.')[0] for mol in mol_p]
        print(molecule_list)

        return molecule_list

    def __init__(self, database_path: Path):
        self.database_path = database_path
        self.paths = GenerateDatabasePaths(database_path)
        self.dalton_path = self.paths.dalton_path
        self.molecule_path = self.paths.molecule_path
        self.json_path = self.paths.json_path

    def generate_molecule_excited_state_keys(self, num_states, overwrite: bool = False):
        """
        Generate excited state keys for a given molecule, xc functional
        and basis set. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """

        mol_excited_path = self.molecule_path.joinpath("molecule_excited_state_keys.json")
        if mol_excited_path.exists():
            with open(mol_excited_path, 'r') as f:
                mol_excited_dict = json.load(f)
            if overwrite:
                mol_list = self.get_molecule_list()
                mol_excited_dict = {mol: num_states for mol in mol_list}
                with open(mol_excited_path, 'w') as f:
                    json.dump(mol_excited_dict, f, indent=4)
            return mol_excited_dict
        else:
            mol_list = self.get_molecule_list()
            mol_excited_dict = {mol: num_states for mol in mol_list}

            if overwrite:
                with open(mol_excited_path, 'w') as f:
                    json.dump(mol_excited_dict, f, indent=4)
            return mol_excited_dict

    def generate_dalton_excited_state_json(self, xc, basis_list, run: bool = False):
        """
        Generate excited state json files for a given xc functional
        and basis set list. Reads data from dalton directory in database_path.
        If data is not found can be generated by running dalton with run = True.
        """
        molecule_list = self.get_molecule_list()
        print('database path', self.database_path)
        print('molecule path', self.molecule_path)

        dal_runner = DaltonRunner(self.database_path, run)
        excited_json_path = self.molecule_path.joinpath("molecule_excited_state_keys.json")

        if excited_json_path.exists():
            with open(excited_json_path, 'r') as f:
                excited_json = json.load(f)
        else:
            excited_json = generate_molecule_excited_state_keys(4, self.database_path, True)

        data_dict = {xc: {}}
        for molecule in molecule_list:
            data_dict[xc][molecule] = {}
            for basis in basis_list:
                data_dict[xc][molecule][basis] = dal_runner.get_excited_json(molecule, xc, basis, run,
                                                                             excited_json[molecule])

        return data_dict

    def update_dalton_excited_state_json(self, xc, basis_list, run):

        if not self.json_path.exists():
            self.json_path.mkdir()
        excited_json = self.generate_dalton_excited_state_json(xc, basis_list, run)

        if self.paths.dalton_excited.exists():
            old_excited_state_json = json.load(open(self.paths.dalton_excited, 'r'))
            old_excited_state_json.update(excited_json)
            with open(self.paths.dalton_excited, 'w') as f:
                json.dump(old_excited_state_json, f, indent=4)

        else:
            with open(self.paths.dalton_excited, 'w') as f:
                json.dump(excited_json, f, indent=4)


def get_molecule_list(database_path: Path):
    """
    Get list of molecules from database path.
    """
    molecule_path = database_path.joinpath("molecules")

    mol_p = glob.glob('*mol', root_dir=molecule_path)
    molecule_list = [mol.split('.')[0] for mol in mol_p]
    print(molecule_list)

    return molecule_list


def generate_molecule_excited_state_keys(num_states, database_path: Path, overwrite: bool = False):
    """
    Generate excited state keys for a given molecule, xc functional
    and basis set. Reads data from dalton directory in database_path.
    If data is not found can be generated by running dalton with run = True.
    """

    paths = GenerateDatabasePaths(database_path)
    dalton_path = paths.dalton_path
    molecule_path = paths.molecule_path

    mol_excited_path = molecule_path.joinpath("molecule_excited_state_keys.json")

    if mol_excited_path.exists():
        with open(mol_excited_path, 'r') as f:
            mol_excited_dict = json.load(f)
        if overwrite:
            mol_list = get_molecule_list(database_path)
            mol_excited_dict = {mol: num_states for mol in mol_list}
            with open(mol_excited_path, 'w') as f:
                json.dump(mol_excited_dict, f, indent=4)
        return mol_excited_dict
    else:
        mol_list = get_molecule_list(database_path)
        mol_excited_dict = {mol: num_states for mol in mol_list}

        if overwrite:
            with open(mol_excited_path, 'w') as f:
                json.dump(mol_excited_dict, f, indent=4)
        return mol_excited_dict


def generate_dalton_excited_state_json(xc, basis_list, database_path: Path, run: bool = False):
    """
    Generate excited state json files for a given xc functional
    and basis set list. Reads data from dalton directory in database_path.
    If data is not found can be generated by running dalton with run = True.
    """
    molecule_path = database_path.joinpath("molecules")
    molecule_list = get_molecule_list(database_path)
    print('database path', database_path)
    print('molecule path', molecule_path)

    dal_runner = DaltonRunner(database_path, run)
    excited_json_path = molecule_path.joinpath("molecule_excited_state_keys.json")
    excited_json = None
    if excited_json_path.exists():
        with open(excited_json_path, 'r') as f:
            excited_json = json.load(f)
    else:
        excited_json = generate_molecule_excited_state_keys(4, database_path, True)

    data_dict = {xc: {}}
    for molecule in molecule_list:
        data_dict[xc][molecule] = {}
        for basis in basis_list:
            data_dict[xc][molecule][basis] = dal_runner.get_excited_json(molecule, xc, basis, run,
                                                                         excited_json[molecule])

    return data_dict
